---
alwaysApply: true
---
# CLMUD Workflow Cheatsheet

## Development Preference
- **PREFER INTERACTIVE LISP DEVELOPMENT** - Use `sbcl --script utils/repl.lisp` for interactive debugging and testing
- **OR PROGRAMMATIC LISP** - Pass in Lisp code directly: `sbcl --eval "(load \"src/packages.lisp\") (load \"src/world.lisp\") ..."`
- **AVOID mud.lisp FOR DEBUGGING** - Don't use `sbcl --script mud.lisp` for testing changes; it's for production server startup only
- Avoid server/telnet debugging unless specifically needed for network protocol issues
- Work in the REPL or with direct Lisp evaluation with loaded packages: `mud.world`, `mud.player`, `mud.mob`, `mud.combat`, `mud.quest`, `mud.server`

## Code Checks & Validation
- **DO NOT START MUD SERVER during code checks** - Use compilation-only validation
- For syntax/compilation checks, use: `./dev.sh check` (compilation only)
- For balance checks only, use: `./dev.sh balance` (parenthesis balance)
- For full validation with server start, use: `./dev.sh validate` (only when testing gameplay)
- Only start the actual MUD server when explicitly testing gameplay or network functionality
- Avoid `sbcl --script mud.lisp` for code validation - use the dev.sh commands instead

## Fast Debugging Tools

**‚ö†Ô∏è NEVER run `mud.lisp` for debugging - it's too slow!**

**Use these tools during development for quick feedback:**

```bash
# Check parenthesis balance (FAST - ~1 second)
./dev.sh balance

# Check compilation only (FAST - ~2 seconds)  
./dev.sh check

# Auto-fix parenthesis issues (FAST - ~1 second)
sbcl --script tools/paren-fix.lisp fix src/server/core.lisp --in-place

# Check specific file balance (FAST)
sbcl --script tools/check_parens.lisp check src/server/core.lisp

# Show detailed analysis (FAST)
sbcl --script tools/check_parens.lisp depth src/server/core.lisp
```

**Only use these when testing gameplay (SLOW):**
```bash
# Full validation with server start (SLOW - ~10+ seconds)
./dev.sh validate

# Start server for gameplay testing (SLOW)
./dev.sh start
```

## Debugging Workflow

**For code changes and fixes:**
1. Edit your code
2. Run `./dev.sh balance` (check parentheses)
3. Run `./dev.sh check` (check compilation)
4. If issues found, fix them and repeat
5. **DONE** - no need to start the server!

**Only start the server when:**
- Testing actual gameplay features
- Verifying player interactions work
- Testing network connectivity
- Final integration testing

**Never start the server for:**
- Syntax checking
- Compilation verification
- Parenthesis balancing
- Code structure validation

## ü§ñ AI Agent Instructions

**‚ö†Ô∏è CRITICAL FOR AI AGENTS: After running `./dev.sh check` - DO NOT run `sbcl --script mud.lisp`!**

**Common AI mistake pattern:**
1. Run `./dev.sh check` ‚úÖ
2. See "compilation successful" ‚úÖ  
3. **INCORRECTLY** run `sbcl --script mud.lisp` ‚ùå

**Correct AI workflow:**
1. Run `./dev.sh check` ‚úÖ
2. See "compilation successful" ‚úÖ
3. **STOP** - compilation check is complete ‚úÖ

**‚ùå AI AGENTS - DON'T do this:**
```bash
./dev.sh check
sbcl --script mud.lisp  # WRONG! Server not needed for compilation check
```

```bash
./dev.sh balance
sbcl --script mud.lisp  # WRONG! Server not needed for balance check
```

```bash
sbcl --script tools/paren-fix.lisp fix file.lisp --in-place
sbcl --script mud.lisp  # WRONG! Server not needed after fixing parentheses
```

**‚úÖ AI AGENTS - DO this instead:**
```bash
./dev.sh balance
./dev.sh check
# DONE! No server needed for development debugging.
```

**When AI should run the server:**
- Only when user explicitly asks to test gameplay
- Only when user says "test the server" or "start the game"
- Only for final integration testing after major changes

**When AI should NOT run the server:**
- After `./dev.sh check` (compilation verification)
- After `./dev.sh balance` (parenthesis checking)  
- After `paren-fix.lisp` (parenthesis fixing)
- For syntax validation
- For code structure verification

## Testing

- **ALWAYS create new test files in the `tests/` directory** - never in the project root
- **KEEP test files** - Don't delete them after testing; they serve as documentation and regression tests
- Use the organized test structure:
  - `tests/unit/` - Unit tests for individual components
  - `tests/commands/` - Command-specific tests  
  - `tests/integration/` - Integration tests for workflows
- Run tests with `./dev.sh tests` (all), `./dev.sh tests-unit`, `./dev.sh tests-cmd`, or `./dev.sh tests-int`
- Individual test files can be run directly: `sbcl --script tests/unit/test-command-registration.lisp`
- Follow the test naming convention: `test-<descriptive-name>.lisp`
- Include proper error handling with `handler-case` in test files
- See [tests/README.md](mdc:tests/README.md) for detailed testing guidelines

## Test File Management

**CRITICAL RULE**: **NEVER DELETE TEST FILES** - Keep all test files as documentation and regression tests!

### Test File Guidelines

1. **Keep All Tests**: Every test file created should be preserved, even if it has package dependency issues
2. **Test File Locations**:
   - Unit tests: `tests/unit/`
   - Command tests: `tests/commands/`
   - Integration tests: `tests/integration/`
   - Feature tests: `tests/features/` (for new features)
3. **Test Naming**: Use descriptive names like `test-dynamic-pricing.lisp`, `test-quest-items.lisp`
4. **Test Documentation**: Tests serve as living documentation of how features work

### Why Keep Tests?

- **Regression Prevention**: Tests catch bugs when code changes
- **Documentation**: Tests show how features are supposed to work
- **Debugging History**: Tests record what issues we've solved
- **Feature Examples**: Tests demonstrate proper usage of new features
