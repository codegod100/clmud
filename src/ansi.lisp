(in-package :mud.ansi)

(defparameter *ansi-table*
  '((:reset . "\e[0m")
    (:bold . "\e[1m")
    (:faint . "\e[2m")
    (:italic . "\e[3m")
    (:underline . "\e[4m")
    (:blink . "\e[5m")
    (:inverse . "\e[7m")
    (:hidden . "\e[8m")
    (:black . "\e[30m")
    (:red . "\e[31m")
    (:green . "\e[32m")
    (:yellow . "\e[33m")
    (:blue . "\e[34m")
    (:magenta . "\e[35m")
    (:cyan . "\e[36m")
    (:white . "\e[37m")
    (:bright-black . "\e[90m")
    (:bright-red . "\e[91m")
    (:bright-green . "\e[92m")
    (:bright-yellow . "\e[93m")
    (:bright-blue . "\e[94m")
    (:bright-magenta . "\e[95m")
    (:bright-cyan . "\e[96m")
    (:bright-white . "\e[97m")
    (:bg-black . "\e[40m")
    (:bg-red . "\e[41m")
    (:bg-green . "\e[42m")
    (:bg-yellow . "\e[43m")
    (:bg-blue . "\e[44m")
    (:bg-magenta . "\e[45m")
    (:bg-cyan . "\e[46m")
    (:bg-white . "\e[47m")
    (:bg-bright-black . "\e[100m")
    (:bg-bright-red . "\e[101m")
    (:bg-bright-green . "\e[102m")
    (:bg-bright-yellow . "\e[103m")
    (:bg-bright-blue . "\e[104m")
    (:bg-bright-magenta . "\e[105m")
    (:bg-bright-cyan . "\e[106m")
    (:bg-bright-white . "\e[107m")))

(defun %normalize-key (key)
  (etypecase key
    (symbol (string-downcase (symbol-name key)))
    (string (string-downcase key))))

(defun code (name)
  (let* ((key (%normalize-key name))
         (pair (assoc (intern key :keyword) *ansi-table* :test #'eq)))
    (cdr pair)))

(defun wrap (text &rest styles)
  (let ((reset (or (code :reset) "")))
    (with-output-to-string (out)
      (dolist (style styles)
        (let ((seq (code style)))
          (when (and seq (plusp (length seq)))
            (write-string seq out))))
      (write-string text out)
      (write-string reset out))))

(defun strip (text)
  (with-output-to-string (out)
    (let ((len (length text))
          (idx 0))
      (loop while (< idx len) do
        (let ((ch (char text idx)))
          (if (and (char= ch #\Esc)
                   (< (1+ idx) len)
                   (char= (char text (1+ idx)) #\[))
              (let ((end (or (position #\m text :start (+ idx 2))
                             (1- len))))
                (setf idx (1+ end)))
              (progn
                (write-char ch out)
                (incf idx))))))))

(defun gradient (text colors)
  (let* ((color-codes (remove-if (lambda (seq) (or (null seq) (zerop (length seq))))
                                 (mapcar #'code colors)))
         (palette-size (length color-codes)))
    (if (zerop palette-size)
        text
        (with-output-to-string (out)
          (let ((len (length text)))
            (dotimes (idx len)
              (let ((seq (nth (mod idx palette-size) color-codes)))
                (write-string seq out)
                (write-char (char text idx) out)))
            (write-string (code :reset) out))))))
